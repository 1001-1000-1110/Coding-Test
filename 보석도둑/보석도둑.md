# Quiz Name
> ### BaekJoon / [Gold 2] <a href = "https://www.acmicpc.net/problem/1202"> 1202.보석도둑 </a>


<br>

## 💡 approaches
>  - 가치가 높은 보석 중 가장 가벼운 보석부터 가방에 담자
>  - 보석을 담을 수 있는 가방 중 가장 가벼운 가방에 담자(이중탐색, O(logN)) 

### problem
1. 이미 사용된 가방을 pop할 경우 시간초과 발생 -> pop(n) : O(N)
2. defaultdic을 사용하여 del(dic[key])를 진행하며 sorted(dic.keys())에 대한 이중탐색을 할 경우 시간초과 발생 -> sorted(arr) : O(NlogN)

## 💡 new approaches
>  - 가방에 넣을 수 있는 보석 중 가장 가치가 높은 보석을 담자
>  - 가벼운 가방부터 담자
>  - 우선순위 큐를 사용하자 (heapq, O(logN))

<br>

## 🔑 quiz solution

```py
import sys, heapq
input = sys.stdin.readline

N, K = map(int, input().rstrip().split())
# 가벼운 -> 가치가 낮은
jewels = sorted([list(map(int, input().rstrip().split())) for _ in range(N)])
# 가벼운
bags = sorted([int(input().rstrip()) for _ in range(K)])

result = 0
jewels_tmp = []
# 가벼운 가방부터
for bag in bags:
    # 가방에 넣을 수 있는 최대 가치의 보석 담기
    while jewels and bag >= jewels[0][0]: # 수용 가능한 보석
        heapq.heappush(jewels_tmp, -heapq.heappop(jewels)[1])
    # 수용 가능한 보석이 있다면
    if jewels_tmp:
        result += heapq.heappop(jewels_tmp) # 그 중 가장 가치가 높은 보석 담기
    elif not jewels: # 수용가능한 보석도 없고 남은 보석도 없다면
        break;

print(-result)
```
### Time Complexity : O((K+N)logN)
    for:bags heapq.pop [Klog(N)] + while:jewel heapq.pop(),heapq.push [Nlog(N)]
## 👩🏻‍🏫 TIL
>  - 두번째 원소를 기준으로 정렬 (sorted(arr, key=lambda x:x[1]))은 두번째 원소가 동일하면 원래의 순서에 맞게 정렬됨
>  - 디폴트인 첫번째 원소를 기준으로 정렬 (sorted(arr))은 첫번째 원소가 동일하면 두번째 원소를 기준으로 정렬됨
>  - sorted() : O(NlogN)
>  - heapq : O(logN)