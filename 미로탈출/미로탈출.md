# Quiz Name
> ### Programmers / [level 2] <a href = "https://school.programmers.co.kr/learn/courses/30/lessons/159993"> 미로탈출 </a>

<br>

## 💡 approaches
>  - 1. 시작점 -> 레버, 레버 -> 끝점 의 최소 거리 계산
>  - 2. 다익스트라
>  - 3. BFS

<br>

## 🔑 quiz solution

## 1. 다익스트라
```py
import heapq

INF = int(1e9)
dydx = ((1,0),(-1,0),(0,1),(0,-1))

def dijkstra(start, end, maps):
    C, R = len(maps[0]), len(maps)
    distance = [[INF]*C for _ in range(R)]
    q = []
    # 우선순위 큐 : 가장 짧은 거리의 노드부터 탐색
    heapq.heappush(q, (0, start[0], start[1]))
    distance[start[0]][start[1]] = 0
    
    while q:
        dist, y, x = heapq.heappop(q)
        # 앞에서 더 짧은 거리를 찾은 경우
        if distance[y][x] < dist: continue
        for dy, dx in dydx:
            _y, _x = y + dy, x + dx
            if not (0 <= _y < R and 0 <= _x < C) or maps[_y][_x] == 'X': continue
            d = dist + 1
            # 현재의 노드를 거쳐서 가는게 더 짧다면
            if d < distance[_y][_x]:
                distance[_y][_x] = d
                heapq.heappush(q, (d, _y, _x))
            if _y == end[0] and _x == end[1]:
                return distance[_y][_x]
    return INF

def solution(maps):
    for i in range(len(maps)):
        for j in range(len(maps[i])):
            c = maps[i][j]
            if c == "S": start = [i, j]
            elif c == "L": lever = [i, j]
            elif c == "E": exit = [i, j]
    answer = dijkstra(start, lever, maps) + dijkstra(lever, exit, maps)
    if answer >= INF: answer = -1
    return answer
```
## 2. BFS
```py
from collections import deque

INF = int(1e9)
dydx = ((1,0),(-1,0),(0,1),(0,-1))

def bfs(start, end, maps):
    C, R = len(maps[0]), len(maps)
    distance = [[0]*C for _ in range(R)]
    q = deque([start])

    while q:
        y, x = q.popleft()
        for dy, dx in dydx:
            _y, _x = y + dy, x + dx
            if not (0 <= _y < R and 0 <= _x < C) or maps[_y][_x] == 'X': continue
            # 해당 노드 처음 방문한 경우 -> 최단 거리
            if distance[_y][_x] == 0:
                distance[_y][_x] = distance[y][x] + 1
                q.append([_y, _x])
            if _y == end[0] and _x == end[1]:
                return distance[_y][_x]
    return INF  

def solution(maps):
    for i in range(len(maps)):
        for j in range(len(maps[i])):
            c = maps[i][j]
            if c == "S": start = [i, j]
            elif c == "L": lever = [i, j]
            elif c == "E": exit = [i, j]
    answer = bfs(start, lever, maps) + bfs(lever, exit, maps)
    if answer >= INF: answer = -1
    return answer
```

### Time Complexity : BFS -> O(N), dijkstra -> O(ElogN)
## 👩🏻‍🏫 TIL
>  - 특정 노드 간의 최단 거리를 구할 경우, BFS와 다익스트라 알고리즘을 사용하여 구할 수 있다. 미로탈출 문제의 경우 간선간의 비용이 1로 고정되어 있기 때문에 첫 방문의 노드일 경우 무조건 최단 거리를 보장하므로, 우선순위 큐(O(logN))를 사용할 필요가 없다. 따라서 시간복잡도가 O(N)인 BFS를 사용하는 것이 효율적이다.