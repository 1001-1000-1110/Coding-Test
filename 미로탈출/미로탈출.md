# Quiz Name
> ### Programmers / [level 2] <a href = "https://school.programmers.co.kr/learn/courses/30/lessons/159993"> ë¯¸ë¡œíƒˆì¶œ </a>

<br>

## ğŸ’¡ approaches
>  - 1. ì‹œì‘ì  -> ë ˆë²„, ë ˆë²„ -> ëì  ì˜ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
>  - 2. ë‹¤ìµìŠ¤íŠ¸ë¼
>  - 3. BFS

<br>

## ğŸ”‘ quiz solution

## 1. ë‹¤ìµìŠ¤íŠ¸ë¼
```py
import heapq

INF = int(1e9)
dydx = ((1,0),(-1,0),(0,1),(0,-1))

def dijkstra(start, end, maps):
    C, R = len(maps[0]), len(maps)
    distance = [[INF]*C for _ in range(R)]
    q = []
    # ìš°ì„ ìˆœìœ„ í : ê°€ì¥ ì§§ì€ ê±°ë¦¬ì˜ ë…¸ë“œë¶€í„° íƒìƒ‰
    heapq.heappush(q, (0, start[0], start[1]))
    distance[start[0]][start[1]] = 0
    
    while q:
        dist, y, x = heapq.heappop(q)
        # ì•ì—ì„œ ë” ì§§ì€ ê±°ë¦¬ë¥¼ ì°¾ì€ ê²½ìš°
        if distance[y][x] < dist: continue
        for dy, dx in dydx:
            _y, _x = y + dy, x + dx
            if not (0 <= _y < R and 0 <= _x < C) or maps[_y][_x] == 'X': continue
            d = dist + 1
            # í˜„ì¬ì˜ ë…¸ë“œë¥¼ ê±°ì³ì„œ ê°€ëŠ”ê²Œ ë” ì§§ë‹¤ë©´
            if d < distance[_y][_x]:
                distance[_y][_x] = d
                heapq.heappush(q, (d, _y, _x))
            if _y == end[0] and _x == end[1]:
                return distance[_y][_x]
    return INF

def solution(maps):
    for i in range(len(maps)):
        for j in range(len(maps[i])):
            c = maps[i][j]
            if c == "S": start = [i, j]
            elif c == "L": lever = [i, j]
            elif c == "E": exit = [i, j]
    answer = dijkstra(start, lever, maps) + dijkstra(lever, exit, maps)
    if answer >= INF: answer = -1
    return answer
```
## 2. BFS
```py
from collections import deque

INF = int(1e9)
dydx = ((1,0),(-1,0),(0,1),(0,-1))

def bfs(start, end, maps):
    C, R = len(maps[0]), len(maps)
    distance = [[0]*C for _ in range(R)]
    q = deque([start])

    while q:
        y, x = q.popleft()
        for dy, dx in dydx:
            _y, _x = y + dy, x + dx
            if not (0 <= _y < R and 0 <= _x < C) or maps[_y][_x] == 'X': continue
            # í•´ë‹¹ ë…¸ë“œ ì²˜ìŒ ë°©ë¬¸í•œ ê²½ìš° -> ìµœë‹¨ ê±°ë¦¬
            if distance[_y][_x] == 0:
                distance[_y][_x] = distance[y][x] + 1
                q.append([_y, _x])
            if _y == end[0] and _x == end[1]:
                return distance[_y][_x]
    return INF  

def solution(maps):
    for i in range(len(maps)):
        for j in range(len(maps[i])):
            c = maps[i][j]
            if c == "S": start = [i, j]
            elif c == "L": lever = [i, j]
            elif c == "E": exit = [i, j]
    answer = bfs(start, lever, maps) + bfs(lever, exit, maps)
    if answer >= INF: answer = -1
    return answer
```

### Time Complexity : BFS -> O(N), dijkstra -> O(ElogN)
## ğŸ‘©ğŸ»â€ğŸ« TIL
>  - íŠ¹ì • ë…¸ë“œ ê°„ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•  ê²½ìš°, BFSì™€ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ êµ¬í•  ìˆ˜ ìˆë‹¤. ë¯¸ë¡œíƒˆì¶œ ë¬¸ì œì˜ ê²½ìš° ê°„ì„ ê°„ì˜ ë¹„ìš©ì´ 1ë¡œ ê³ ì •ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— ì²« ë°©ë¬¸ì˜ ë…¸ë“œì¼ ê²½ìš° ë¬´ì¡°ê±´ ìµœë‹¨ ê±°ë¦¬ë¥¼ ë³´ì¥í•˜ë¯€ë¡œ, ìš°ì„ ìˆœìœ„ í(O(logN))ë¥¼ ì‚¬ìš©í•  í•„ìš”ê°€ ì—†ë‹¤. ë”°ë¼ì„œ ì‹œê°„ë³µì¡ë„ê°€ O(N)ì¸ BFSë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ íš¨ìœ¨ì ì´ë‹¤.