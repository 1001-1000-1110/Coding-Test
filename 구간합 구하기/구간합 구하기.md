# Quiz Name
> ### BaekJoon / [Gold 1] <a href = "https://www.acmicpc.net/problem/2042"> 2042.구간합 구하기 </a>
<br>

## 💡 approaches
>  - 단순히 배열에 저장
>  - 값을 변경할 경우 인덱스로 접근하여 변경 arr[b] = c **O(1)**
>  - 합을 구할 경우 sum함수를 통해 구함 sum(arr[b:c+1]) -> **O(N)**

### problem
시간초과 발생. M번의 연산을 수행한다면 O(M*1) + O(M*N) = **O(MN)**

## 💡 new approaches
>  - 세그먼트 트리 구현

## 🌴 segment tree
완전이진트리 구조이며, 값의 변경과 합을 구할 경우 각각 O(logN)의 시간복잡도를 갖는다. M번의 연산을 수행한다면 O(MlogN + MlogN) = **O(MlogN)**
## segment tree 예시
- 원소의 개수가 11개일 경우
<img width="770" alt="스크린샷 2023-02-21 오후 1 14 12" src="https://user-images.githubusercontent.com/97938489/220246117-1ea8af59-eb9a-40e7-9246-584ac6ac1742.png">
리프에는 배열의 원소를 저장. 그림에 노드에 있는 숫자 start~end 는 배열의 인덱스 start부터 end까지의 합을 의미한다. 트리 생성 시, 루트노드부터 시작하여 부분합을 저장한다.
## 각 노드가 갖는 의미
1. start : 배열의 시작 인덱스
2. end : 배열의 끝 인덱스
3. node : tree의 인덱스며 루트노드 부터 시작하여 왼쪽에서 오른쪽 방향으로 증가

<br>

## 🔑 quiz solution

```py
import sys
input = sys.stdin.readline

# (시작 인덱스, 끝 인덱스, 노드)
# 루트에서부터 재귀적으로 트리 생성
def init(start, end, node):
    if start == end: # 리프라면
        tree[node] = arr[start]
    else:
        mid = (start + end) // 2
        tree[node] = init(start, mid, node*2) + init(mid+1, end, node*2+1)
    return tree[node]

# (시작 인덱스, 끝 인덱스, 노드, 변경 인덱스, 값 차이)
# 변경하려는 값과 관련된 노드들을 업데이트 해줌
def update(start, end, node, index, diff):
    # 변경하려는 값과 관련이 있는 노드라면
    if start <= index <= end:
        # update
        tree[node] += diff
        if start == end: return # 리프라면
        mid = (start + end) // 2
        update(start, mid, node*2, index, diff)
        update(mid+1, end, node*2+1, index, diff)

# (시작 인덱스, 끝 인덱스, 노드, 합 시작 인덱스, 합 끝 인덱스)
def find(start, end, node, index1, index2):
    # 구하려는 값과 관련 있는 노드라면
    if not (index2 < start or end < index1):
        # 이미 트리에 계산된 값이라면
        if index1 <= start and end <= index2:
            return tree[node]
        mid = (start + end) // 2
        return find(start, mid, node*2, index1, index2) + find(mid+1, end, node*2+1, index1, index2)
    return 0
    
N, M, K = map(int, input().split())

# 세그먼트 트리 크기 -> 루트노드부터 1 + 2 + 4 + 8 + ... 2^k
# 2^k <= N -> 트리 크기 = 2^(K+1)개
# 간단한 방법 : N*4개
tree = [0] * N * 4
arr = [0] + [int(input()) for _ in range(N)]
init(1, N, 1)

for _ in range(M+K):
    a, b, c = map(int, input().split())
    if a == 1:
        update(1, N, 1, b, c-arr[b])
        arr[b] = c
    else: print(find(1, N, 1, b, c))
```
### Time Complexity : O((M+K)logN)
## 👩🏻‍🏫 TIL
>  - 세그먼트 트리의 시간복잡도 O(logN)