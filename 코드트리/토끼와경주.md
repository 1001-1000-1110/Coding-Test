# Quiz Name
> ### CodeTree / [Gold1] <a href = "https://www.codetree.ai/training-field/frequent-problems/problems/rabit-and-race/description?page=1&pageSize=20"> í† ë¼ì™€ ê²½ì£¼ </a>

<br>

## ğŸ’¡ approaches
> - simulation  


<br>

## ğŸ”‘ quiz solution

```java
import java.util.*;
import java.io.*;

public class í† ë¼ì™€ê²½ì£¼ {

    //Pointí´ë˜ìŠ¤ êµ¬í˜„
    static class Point {
        int x;
        int y;

        public Point(int x, int y) {
            super();
            this.x = x;
            this.y = y;
        }


    }

    //Rabbit í´ë˜ìŠ¤ êµ¬í˜„
    static class Rabbit implements Comparable<Rabbit> {
        int jump;
        Point point;
        int id;

        public Rabbit(int jump, Point point, int id) {
            super();
            this.jump = jump;
            this.point = point;
            this.id = id;
        }

        @Override
        public int compareTo(Rabbit o) {
            //ì í”„ê°€ ë‹¤ë¥¸ê²½ìš°
            if (this.jump != o.jump) {
                return Integer.compare(this.jump, o.jump);
            } else {
                //í–‰+ì—´ì´ ë‹¤ë¥¸ ê²½ìš°
                if (this.point.x + this.point.y != o.point.x + o.point.y) {
                    return Integer.compare(this.point.x + this.point.y, o.point.x + o.point.y);
                } else {
                    //í–‰ë¹„êµ
                    if (this.point.x != o.point.x) {
                        return Integer.compare(this.point.x, o.point.x);
                    } else {
                        if (this.point.y != o.point.y) {
                            return Integer.compare(this.point.y, o.point.y);
                        } else {
                            return Integer.compare(this.id, o.id);
                        }
                    }
                }
            }
        }


    }

    //Position í´ë˜ìŠ¤ êµ¬í˜„
    static class Position implements Comparable<Position> {
        Point point;
        int id;

        public Position(Point point, int id) {
            super();
            this.point = point;
            this.id = id;
        }

        @Override
        public int compareTo(Position o) {
            //í–‰+ì—´ì´ ë‹¤ë¥¸ ê²½ìš°
            if (this.point.x + this.point.y != o.point.x + o.point.y) {
                return -1 * Integer.compare(this.point.x + this.point.y, o.point.x + o.point.y);
            } else {
                //í–‰ë¹„êµ
                if (this.point.x != o.point.x) {
                    return -1 * Integer.compare(this.point.x, o.point.x);
                } else {
                    if (this.point.y != o.point.y) {
                        return -1 * Integer.compare(this.point.y, o.point.y);
                    } else {
                        return -1 * Integer.compare(this.id, o.id);
                    }
                }
            }
        }

    }

    //PriorityQueue<Rabbit>
    static PriorityQueue<Rabbit> rabbitPq = new PriorityQueue<>();
    //PriorityQueue<Position> êµ¬í˜„
    static PriorityQueue<Position> positionPq = new PriorityQueue<>();

    //í† ë¼ì˜ ì´ˆê¸° ì •ë³´ë“¤ì„ ë‹´ìŒ
    static int[] ids; //í† ë¼ì˜ ì•„ì´ë””
    static HashMap<Integer, Integer> idToIdx = new HashMap<>();
    static Point[] points;//í† ë¼ì˜ ìœ„ì¹˜
    static long[] scores;//í† ë¼ì˜ ì ìˆ˜
    static int[] dists;//í† ë¼ì˜ ì´ë™ê±°ë¦¬
    static int[] jumps;//ì í”„íšŸìˆ˜
    static boolean[] isMove;//200ì—ì„œ í•œë²ˆì´ë¼ë„ ì´ë™í•œ í† ë¼ë¥¼ ì°¾ìŒ
    static int n, m, p;

    public static void main(String[] args) throws NumberFormatException, IOException {
        solve();

    }

    private static void solve() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int q = Integer.parseInt(br.readLine());
        for (int i = 0; i < q; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int code = Integer.parseInt(st.nextToken());
            if (code == 100) {
                init(st);
            } else if (code == 200) {
                func200(st);
            } else if (code == 300) {
                func300(st);
            } else { //code == 400
                func400();
            }
        }
    }

    private static void func400() {
        long result = Long.MIN_VALUE;
        for (int i = 0; i < p; i++) {
            result = Math.max(result, scores[i]);
        }
        System.out.println(result);

    }

    private static void func300(StringTokenizer st) {
        int id = Integer.parseInt(st.nextToken());
        int l = Integer.parseInt(st.nextToken());

        int idx = idToIdx.get(id);
        dists[idx] *= l;


    }

    private static void func200(StringTokenizer st) {
        int k = Integer.parseInt(st.nextToken());
        int s = Integer.parseInt(st.nextToken());
        Arrays.fill(isMove, false);

        for (int i = 0; i < k; i++) {
            Rabbit now = rabbitPq.poll();
            int dist = dists[idToIdx.get(now.id)];//ì›€ì§ì—¬ì•¼í•  ê±°ë¦¬

            positionPq.clear();

            positionPq.add(new Position(moveUp(now.point, dist), now.id));
            positionPq.add(new Position(moveDown(now.point, dist), now.id));
            positionPq.add(new Position(moveLeft(now.point, dist), now.id));
            positionPq.add(new Position(moveRight(now.point, dist), now.id));

            //í•˜ë‚˜ë§Œ ë½‘ìŒ
            Position position = positionPq.poll();
            int idx = idToIdx.get(position.id);

            //isMoveì— ì´ë™í–ˆìŒì„ ì²´í¬í•¨
            isMove[idx] = true;

            //jumpíšŸìˆ˜ ì¦ê°€
            jumps[idx]++;

            //ìœ„ì¹˜ ê°±ì‹ 
            points[idx] = position.point;
            //ë‹¤ë¥¸ í† ê¸°ë“¤ì—ê²Œ ì ìˆ˜ ë¶€ì—¬
            int score = position.point.x + position.point.y;
            for (int j = 0; j < p; j++) {
                if (j == idx) continue;
                scores[j] += score;
            }
//			System.out.println(i);
//			System.out.println(Arrays.toString(scores));
            rabbitPq.add(new Rabbit(jumps[idx], position.point, position.id));

        }

        //ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë†’ì€ í† ë¼ì—ê²Œ ì ìˆ˜ ì§€ê¸‰
        positionPq.clear();
        for (int i = 0; i < p; i++) {
            if (!isMove[i]) continue;
            positionPq.add(new Position(points[i], ids[i]));
        }

        Position position = positionPq.poll();
        int idx = idToIdx.get(position.id);
        scores[idx] += s;
        //ë°˜ë³µë¬¸
        //rabbitPqì—ì„œ í•˜ë‚˜ ì¶”ì¶œ
        //TODO ìƒí•˜ì¢Œìš° ì´ë™ ì‹œí‚´
        //TODO ì´ë™ì‹œí‚¨ ì¢Œí‘œë¥¼ ë°›ì•„ì„œ PriorityQueue positionPqì— ë„£ìŒ
        //positionPqì´ˆê¸°í™”
        //TODO í•˜ë‚˜ë§Œ ì¶”ì¶œí•¨
        //TODO í•´ë‹¹ í† ë¼ì˜ idxë¥¼ êµ¬í•œë’¤, ë‚˜ë¨¸ì§€ í† ë¼ë“¤ì—ê²Œ Së¶€ì—¬
        //isMoveì²´í¬
        //rabbitPqì— ë„£ìŒ

        //isMoveë¥¼ í†µí•´ positionPqì— í† ë¼ë“¤ ìµœì‹ ê°’ ë„£ìŒ
        //í•˜ë‚˜ë§Œ ì¶”ì¶œí•´ì„œ scoreì— ì ìˆ˜ ë¶€ì—¬
        //positionPqì´ˆê¸°í™”
        //rabbitPqì— ë„£ìŒ
    }

    private static Point moveRight(Point point, int dist) {
        int x = point.x;
        int y = point.y;
        dist %= 2 * (m - 1);

        //ì˜¤ë¥¸ìª½ ì´ë™ì‹œ ë²½ê³¼ ë¶€ë”ªíˆì§€ ì•ŠìŒ
        if (dist <= m - y) {
            y += dist;
            dist = 0;
        } else {
            dist -= (m - y);
            y = m;
        }

        //ì™¼ì¡±ìœ¼ë¡œ ì´ë™ì‹œ ë²½ê³¼ ë¶€ë”ªíˆì§€ ì•ŠìŒ
        if (dist <= m - 1) {
            y -= dist;
            dist = 0;
        } else {
            y = 1;
            dist -= (m - 1);
        }

        y += dist;

        return new Point(x, y);
    }

    private static Point moveLeft(Point point, int dist) {
        int x = point.x;
        int y = point.y;
        dist %= 2 * (m - 1);

        //ì™¼ìª½ìœ¼ë¡œ ì´ë™ì‹œ, ë²½ê³¼ ë¶€ë”ªíˆì§€ ì•ŠìŒ.
        if (dist <= (y - 1)) {
            y -= dist;
            dist = 0;
        } else {
            dist -= (y - 1);
            y = 1;
        }

        //ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ì‹œ,ë²½ê³¼ ë¶€ë”ªíˆì§€ ì•ŠìŒ
        if (dist <= (m - 1)) {
            y += dist;
            dist = 0;
        } else {
            y = m;
            dist -= (m - 1);
        }

        y -= dist;
        return new Point(x, y);
    }

    private static Point moveDown(Point point, int dist) {
        int x = point.x;
        int y = point.y;
        dist %= 2 * (n - 1);

        //ì•„ë˜ë¡œ ì´ë™í•´ë„ ë²½ê³¼ ë¶€ë”ªíˆì§€ ì•ŠëŠ” ê²½ìš°, ê·¸ëƒ¥ ì´ë™ ì‹œí‚´
        if (dist <= n - x) {
            x = x + dist;
            dist = 0;
        } else {//ë²½ê³¼ ë¶€ë”ªíˆëŠ” ê²½ìš°
            dist -= (n - x);
            x = n;
        }

        //ìœ„ë¡œ ì´ë™í–ˆì„ë•Œ ë²½ê³¼ ë¶€ë”ªíˆì§€ ì•ŠëŠ” ê²½ìš°, ê·¸ëƒ¥ ì´ë™ì‹œí‚´
        if (dist <= (n - 1)) {
            x -= dist;
            dist = 0;
        } else { //ë²½ê³¼ ë¶€ë”ªí˜
            dist -= (n - 1);
            x = 1;
        }

        x += dist;

        return new Point(x, y);
    }

    private static Point moveUp(Point point, int dist) {
        int x = point.x;
        int y = point.y;
        dist %= 2 * (n - 1);

        //ìœ„ë¡œ ì´ë™í•´ë„ ë²½ê³¼ ë¶€ë”ªíˆì§€ ì•ŠëŠ” ê²½ìš°, ê·¸ëƒ¥ ì´ë™ì‹œí‚´
        if (dist <= x - 1) {
            x -= dist;
            dist = 0;
        } else {//ë²½ì— ë¶€ë”ªíˆëŠ” ê²½ìš°
            dist -= (x - 1);
            x = 1;
        }

        //ì•„ë˜ë¡œ ì´ë™í–ˆì„ ë•Œ ë²½ê³¼ ë¶€ë”ªíˆì§€ ì•ŠëŠ” ê²½ìš°, ê·¸ëƒ¥ ì´ë™ì‹œí‚´
        if (dist <= n - 1) {
            x += dist;
            dist = 0;
        } else { //ë²½ì— ë¶€ë”ªíˆëŠ” ê²½ìš°
            dist -= (n - 1);
            x = n;
        }

        x -= dist;
        return new Point(x, y);
    }

    private static void init(StringTokenizer st) {
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        p = Integer.parseInt(st.nextToken());

        points = new Point[p];
        scores = new long[p];
        dists = new int[p];
        jumps = new int[p];
        ids = new int[p];
        isMove = new boolean[p];
        //ië²ˆì§¸ í† ë¼ì˜ ìœ„ì¹˜, ì ìˆ˜,ì´ë™ê±°ë¦¬ë¥¼ ì´ˆê¸°í™”í•¨
        for (int i = 0; i < p; i++) {
            int id = Integer.parseInt(st.nextToken());
            int dist = Integer.parseInt(st.nextToken());

            points[i] = new Point(1, 1);
            dists[i] = dist;
            ids[i] = id;
            idToIdx.put(id, i);
        }

        //rabbitsPqì˜ ì´ˆê¸°ê°’ì„ ì„¤ì •í•¨.
        for (int i = 0; i < p; i++) {
            rabbitPq.add(new Rabbit(0, points[i], ids[i]));
        }

    }
}

```
### Time Complexity : O(PlogP)
## ğŸ‘©ğŸ»â€ğŸ« TIL
>  - ë²½ì— ë¶€ë”ªíˆë©´ ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ ì§„í–‰í•˜ëŠ” 2ì°¨ì› ë°°ì—´ë‹¤ë£¨ëŠ” í•¨ìˆ˜ì˜ ì‹œê°„ì¤„ì´ëŠ” ë²•

