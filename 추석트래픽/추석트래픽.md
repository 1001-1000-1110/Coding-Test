# Quiz Name
> ### Programmers / [level 3] <a href = "https://school.programmers.co.kr/learn/courses/30/lessons/17676"> 추석트래픽 </a>

<br>

## 💡 approaches
>  - 시작과 끝 시간을 저장하여 특정 요청의 끝시간~끝시간+999ms 사이의 요청의 개수를 카운트

<br>

## 🔑 quiz solution

```java
import java.util.*;

class Solution {
    int convertMs(String time) {
        String[] temp = time.split(":");
        return (int)((Integer.parseInt(temp[0])*60*60+Integer.parseInt(temp[1])*60+Double.parseDouble(temp[2]))*1000);
    }
    
    public int solution(String[] lines) {
        int answer = 0;
        List<Request> list = new ArrayList<>();
        int start = 0, end = 0;
        
        for (int i=0;i<lines.length;i++) {
            String[] temp;
            temp = lines[i].split(" ");
            end = convertMs(temp[1]);
            
            if (end == 0) {
                start = 0;
            } else {
                temp[2] = temp[2].substring(0, temp[2].length()-1);
                start = end - (int)((Double.parseDouble(temp[2]) * 1000)) + 1;
            }
            list.add(new Request(start, end));
        }
        
        int temp;
        for (int i=0;i<list.size();i++) {
            temp = 1;
            // i+1부터는 나보다 다 늦게 끝나는 request
            for (int j=i+1;j<list.size();j++){
                // j의 시작시간 <= i의 끝시간 + 999
                // 즉, i의 끝시간부터 i의 끝시간 + 999까지에 존재하는 요청들 카운트
                if (list.get(j).start <= list.get(i).end+999) {
                    temp++;
                }
            }
            if (answer<temp){
                answer = temp;
            }
        }
        return answer;
    }
    
    class Request {
        int start;
        int end;
        
        Request(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
}
```
### Time Complexity : O(N^2)
## 👩🏻‍🏫 TIL
- 메모리 사용량이 초과될 것 같으면 바로 다른 알고리즘을 생각해보자
- 정수 + 실수 = 실수
