# Quiz Name
> ### Programmers / [level] <a href = "https://school.programmers.co.kr/learn/courses/30/lessons/84021"> í¼ì¦ ì¡°ê° ì±„ìš°ê¸° </a>

<br>

## ğŸ’¡ approaches
>  - 
>  - 

<br>

## ğŸ”‘ quiz solution

```java

import java.util.*;

class Solution {
    static int N;
    static class Point{
        int x;
        int y;
        public Point(int x, int y){
            this.x = x;
            this.y = y;
        }
    }
    public int solution(int[][] game_board, int[][] table) {
        N = game_board.length;
        int[][] game_board_copy = new int[N][N]; //game_board ê¹Šì€ ë³µì‚¬ë³¸
        int[][] table_copy = new int[N][N]; // table ê¹Šì€ ë³µì‚¬ë³¸

        for(int i = 0; i < N; i++){
            game_board_copy[i] = game_board[i].clone();
            table_copy[i] = table[i].clone();
        }

        /*game_boardì™€ tableì—ì„œ ê° ëª¨ì–‘ì„ ì¶”ì¶œí•¨*/
        List<List<Point>> board = new ArrayList<>();
        List<List<Point>> puzzle = new ArrayList<>();

        //bfsë¥¼ í†µí•´  game_board_copyì˜ ë¹ˆê³µê°„, table_copyì˜ ë„í˜•ì„ ì¶”ì¶œí•¨
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
                if(game_board_copy[i][j] == 0){//game_boardì—ì„œ 0ì€ êµ¬ë©ì„
                    board.add(bfs(i,j,0,game_board_copy));
                }

                if(table_copy[i][j] == 1){//tableì—ì„œ 1ì€ ë„í˜•ì„
                    puzzle.add(bfs(i,j,1,table_copy));
                }
            }
        }
        //board , puzzleì˜ ì¢Œí‘œë¥¼ ë¹„êµê°€ ê°€ëŠ¥í•˜ë„ë¡ êµ¬ë©/ë„í˜•ì„ ê°ì‹¸ëŠ” ì‚¬ê°í˜• í˜•íƒœë¡œ ì¢Œí‘œë¥¼ ë§Œë“¤ì–´ì¤Œ
        List<int[][]> boardHole = makeRectangle(board, game_board);
        List<int[][]> puzzleBlock = makeRectangle(puzzle, table);

        /*game_boardì—ì„œ ì¶”ì¶œí•œ ì‚¬ê°í˜•ì„ íšŒì „ì‹œì¼œê°€ë©° tableì—ì„œ ì¶”ì¶œí•œ ì‚¬ê°í˜•ê³¼ ë¹„êµí•¨*/
        boolean[] visited = new boolean[puzzleBlock.size()];

        for(int i = 0; i < boardHole.size(); i++){
            int[][] now = boardHole.get(i);

            for(int j = 0; j < puzzleBlock.size(); j++){
                if(visited[j] == true)
                    continue;

                int[][] block = puzzleBlock.get(j);
                isCorrect(now,block,j, visited);
                if(visited[j] == true)
                    break;
                //90ë„ íšŒì „
                now = rotate(now);
                isCorrect(now,block,j, visited);
                if(visited[j] == true)
                    break;
                //180ë„ íšŒì „
                now = rotate(now);
                isCorrect(now,block,j, visited);
                if(visited[j] == true)
                    break;

                //270ë„ íšŒì „
                now = rotate(now);
                isCorrect(now,block,j, visited);
                if(visited[j] == true)
                    break;

            }
        }

        int answer = 0;

        for(int i = 0; i < puzzle.size(); i++){
            if(visited[i] == true){
                answer += puzzle.get(i).size();
            }
        }

        return answer;
    }

    //bfs
    // (ì‹œì‘ì§€ì x, ì‹œì‘ì§€ì y, ì°¾ëŠ” ê°’(1 or 0), bfsë¥¼ ì§„í–‰í•  ë§µ)
    private List<Point> bfs(int x, int y, int target, int[][] map){
        int dx[] = {-1, 1, 0, 0};
        int dy[] = {0, 0, -1, 1};

        Queue<Point> q = new LinkedList<>();
        q.add(new Point(x,y));
        map[x][y] = (target == 0) ? 1 : 0; //ë°©ë¬¸í–ˆìŒì„ í‘œì‹œí•¨

        List<Point> result = new ArrayList<>();

        while(!q.isEmpty()){
            Point now = q.poll();
            result.add(new Point(now.x, now.y));
            for(int i = 0; i < 4; i++){
                int nextX = now.x + dx[i];
                int nextY = now.y + dy[i];
                if(nextX >= 0 && nextX < N && nextY >= 0 && nextY < N && map[nextX][nextY] == target){
                    q.add(new Point(nextX, nextY));
                    map[nextX][nextY] = (target == 0) ? 1 : 0;//ë°©ë¬¸í–ˆìŒì„ í‘œì‹œí•¨.
                }

            }
        }
        return result;
    }

    //ì…ë ¥ëœ ì¢Œí‘œë“¤ì„ ëª¨ë‘ í¬í•¨í•˜ëŠ”, mapìƒì˜ ì§ì‚¬ê°í˜•ì„ ëª¨ë‘ ì¢Œí‘œë¡œ ë§Œë“¤ì–´ ë°˜í™˜í•¨
    //((êµ¬ë©ì´ë‚˜ or ë„í˜•) ì¢Œí‘œ ëª¨ìŒ), ì°¸ê³ í•  map(game_board or table))
    private List<int[][]> makeRectangle(List<List<Point>> list, int[][] map){

        List<int[][]> result = new ArrayList<>();
        //í¬í•¨ë˜ì–´ ìˆëŠ” ì¢Œí‘œë“¤ì„ ëª¨ë‘ í¬í•¨í•˜ëŠ” ì§ì‚¬ê°í˜•ì„ ë§Œë“¬
        for(int i = 0; i < list.size(); i++){
            List<Point> points = list.get(i);

            int minx = Integer.MAX_VALUE;
            int maxx = Integer.MIN_VALUE;
            int miny = Integer.MAX_VALUE;
            int maxy = Integer.MIN_VALUE;
            for(Point point : points){
                minx = Math.min(minx, point.x);
                maxx = Math.max(maxx, point.x);
                miny = Math.min(miny, point.y);
                maxy = Math.max(maxy, point.y);
            }
            //ëª¨ë“  ì‚¬ê°í˜•ì˜ ì‹œì‘ì§€ì ì„ (0,0)ìœ¼ë¡œ ë§Œë“¬
            int[][] rectangle = new int[maxx - minx + 1][maxy - miny + 1];

            for(int j = minx; j <= maxx; j++){
                for(int k = miny; k<= maxy; k++){
                    rectangle[j - minx][k - miny] = map[j][k];
                }
            }

            result.add(rectangle);
        }

        return result;
    }

    //ë¹„êµ ëŒ€ìƒì´ë˜ëŠ” ë‘ê°œì˜ ì‚¬ê°í˜•ì¢Œí‘œëª¨ìŒì´ ì¼ì¹˜í•œì§€ íŒë‹¨í•¨.
    private void isCorrect(int[][] now, int[][]block, int index, boolean[] visited){

        if(now.length != block.length || now[0].length != block[0].length){
            return;
        }

        for(int k = 0; k < block.length; k++){
            for(int l = 0; l < block[0].length; l++){
                if(now[k][l] == block[k][l]){ //ê°™ì€ ê²½ìš° ì¢…ë£Œ, í•˜ë‚˜ëŠ” êµ¬ë©(0) í•˜ë‚˜ëŠ” ë„í˜•(1)ì´ë¯€ë¡œ ë‘ê°œê°€ ë‹¬ë¼ì•¼í•¨.
                    return;
                }
            }
        }
        visited[index] = true;
    }

    //90ë„ íšŒì „
    private int[][] rotate(int[][] map){
        int[][] temp = new int[map.length][map[0].length];

        for(int i = 0; i < map.length; i++){
            temp[i] = map[i].clone();
        }

        int[][] rotated = new int[temp[0].length][temp.length];

        for(int i = 0;  i < temp.length; i++){
            for(int j = 0; j < temp[0].length; j++){
                rotated[j][rotated[0].length - 1 - i] = temp[i][j];
            }
        }
        return rotated;
    }
}
```
### Time Complexity : O(N<sup>2</sup>)
## ğŸ‘©ğŸ»â€ğŸ« TIL
>  -
>  -
