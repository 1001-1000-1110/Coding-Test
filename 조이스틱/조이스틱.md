# Quiz Name
> ### Programmers / [level 2] <a href = "https://school.programmers.co.kr/learn/courses/30/lessons/42860#"> 조이스틱 </a>

<br>

## 💡 approaches
>  - 그리디로 접근하여 왼쪽으로 이동할지 오른쪽으로 이동할지 선택
>  - 기준은 현재 위치에서의 최소 이동거리를 선택하는 방향

## problem
>  - 그리디로 접근한다면 왼쪽과 오른쪽 중 선택하는 기준이 정당해야하지만 마땅한 기준이 없다.
>  - 예를 들어 "BBBBAAAABA"인 경우, 현재 위치에서 가장 가까운 순으로 접근한다면 오른쪽으로 먼저 이동해야하는데 실제론 왼쪽으로 두칸 이동 후에 다시 오른쪽으로 이동을 해야 최소 이동거리가 나온다.


## 💡 new approaches
>  - dfs로 접근해보자.

<br>

## 🔑 quiz solution

```py
def dfs(now, count, name, n, notA):
    if not notA: return count
    # 오른쪽으로 이동
    right = dfs(notA[0], count+abs(notA[0]-now), name, n, notA[1:])
    # 왼쪽으로 이동 (now < 0)
    left = dfs(notA[-1]-n, count+now+n-notA[-1], name, n, notA[:-1])
    # 최솟값 반환
    return min(left, right)
        
def solution(name):
    answer = 0
    notA = []
    n = len(name)
    for i in range(n):
        if name[i] != "A":
            notA.append(i)
            answer += min(ord(name[i])-ord("A"), ord("Z")-ord(name[i])+1)
    answer += dfs(0, 0, name, n, notA)
    return answer
```
### Time Complexity : O(V), V는 간선의 개수로 2^N-2개
## 👩🏻‍🏫 TIL