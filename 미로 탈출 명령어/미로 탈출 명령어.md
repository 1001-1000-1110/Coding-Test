# Quiz Name
> ### Programmers / [level 3] <a href = "https://school.programmers.co.kr/learn/courses/30/lessons/150365"> 미로 탈출 명령어 </a>

<br>

## 💡 approaches
>  - bfs
>  - 단순 bfs 완전탐색으로 접근 -> 시간 초과 발생
>  - 문자열 사전 순으로 가장 빠른 path를 선택해야하기 때문에 사전 순인 d -> l -> r -> u순으로 방향 전환
>  - 방향 전환을 하면서 k번만에 도착지에 도달할 수 있는 경우인지 판단
>  - 사전 순으로 방향전환을 하기 때문에 해당 방향이 목적지에 도달할 수 있는 경우, 다른 방향은 고려할 필요도 없음

<br>

## 🔑 quiz solution

```py
from collections import deque
# 사전순 dlru
dxdy = (("d", 1, 0), ("l", 0, -1), ("r", 0, 1), ("u", -1, 0))

def solution(n, m, x, y, r, c, k):
    q = deque([[x, y, ""]])
    while q:
        x, y, path = q.popleft()
        l = len(path)

        # 정답을 찾았다면
        if (l, x, y) == (k, r, c): return path

        # 이동해야할 거리가 아직 남았다면
        if l < k:
            l += 1
            for direc, dx, dy in dxdy:
                _x, _y, _path = x + dx, y + dy, path + direc

                if not (1 <= _x <= n and 1 <= _y <= m): continue

                # 해당 방향으로 선택할 경우, 목적지에 도달할 수 없는 경우
                if abs(_x-r) + abs(_y-c) > k-l: continue

                # 적절한 방향을 찾았다면 큐에 담은 후 break
                q.append([_x, _y, _path])
                break
            
    return "impossible"
```
### Time Complexity : O(N^2M^2) 큐에 담기는 노드 O(NM) * 각 노드에 의해 담기는 노드 O(NM)
## 👩🏻‍🏫 TIL